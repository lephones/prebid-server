
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rubicon: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/prebid/prebid-server/v3/adapters/rubicon/rubicon.go (83.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rubicon

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/prebid/prebid-server/v3/version"

        "github.com/prebid/prebid-server/v3/adapters"
        "github.com/prebid/prebid-server/v3/config"
        "github.com/prebid/prebid-server/v3/errortypes"
        "github.com/prebid/prebid-server/v3/openrtb_ext"
        "github.com/prebid/prebid-server/v3/util/jsonutil"
        "github.com/prebid/prebid-server/v3/util/maputil"

        "github.com/buger/jsonparser"
        "github.com/prebid/openrtb/v20/openrtb2"
)

const badvLimitSize = 50

var bannerExtContent = []byte(`{"rp":{"mime":"text/html"}}`)

type RubiconAdapter struct {
        URI          string
        externalURI  string
        XAPIUsername string
        XAPIPassword string
}

type rubiconData struct {
        AdServer rubiconAdServer `json:"adserver"`
        PbAdSlot string          `json:"pbadslot"`
}

type rubiconAdServer struct {
        Name   string `json:"name"`
        AdSlot string `json:"adslot"`
}

type rubiconExtImpBidder struct {
        Prebid *openrtb_ext.ExtImpPrebid `json:"prebid"`
        Bidder openrtb_ext.ExtImpRubicon `json:"bidder"`
        Gpid   string                    `json:"gpid"`
        Skadn  json.RawMessage           `json:"skadn,omitempty"`
        Tid    string                    `json:"tid"`
        Data   json.RawMessage           `json:"data"`
}

type bidRequestExt struct {
        Prebid bidRequestExtPrebid `json:"prebid"`
}

type bidRequestExtPrebid struct {
        Bidders bidRequestExtPrebidBidders `json:"bidders"`
}

type bidRequestExtPrebidBidders struct {
        Rubicon prebidBiddersRubicon `json:"rubicon,omitempty"`
}

type prebidBiddersRubicon struct {
        Debug prebidBiddersRubiconDebug `json:"debug,omitempty"`
}

type prebidBiddersRubiconDebug struct {
        CpmOverride float64 `json:"cpmoverride,omitempty"`
}

type rubiconImpExtRPTrack struct {
        Mint        string `json:"mint"`
        MintVersion string `json:"mint_version"`
}

type rubiconImpExt struct {
        RP    rubiconImpExtRP `json:"rp,omitempty"`
        GPID  string          `json:"gpid,omitempty"`
        Skadn json.RawMessage `json:"skadn,omitempty"`
        Tid   string          `json:"tid,omitempty"`
}

type rubiconImpExtRP struct {
        ZoneID int                  `json:"zone_id"`
        Target json.RawMessage      `json:"target,omitempty"`
        Track  rubiconImpExtRPTrack `json:"track"`
}

type rubiconUserExtRP struct {
        Target json.RawMessage `json:"target,omitempty"`
}

type rubiconDataExt struct {
        SegTax int `json:"segtax"`
}

type rubiconUserExt struct {
        Eids    []openrtb2.EID   `json:"eids,omitempty"`
        RP      rubiconUserExtRP `json:"rp"`
        Data    json.RawMessage  `json:"data,omitempty"`
        Consent string           `json:"consent,omitempty"`
}

type rubiconSiteExtRP struct {
        SiteID int             `json:"site_id"`
        Target json.RawMessage `json:"target,omitempty"`
}

type rubiconSiteExt struct {
        RP rubiconSiteExtRP `json:"rp"`
}

type rubiconPubExtRP struct {
        AccountID int `json:"account_id"`
}

type rubiconPubExt struct {
        RP rubiconPubExtRP `json:"rp"`
}

type rubiconBannerExtRP struct {
        MIME string `json:"mime"`
}

type rubiconBannerExt struct {
        RP rubiconBannerExtRP `json:"rp"`
}

// ***** Video Extension *****
type rubiconVideoExt struct {
        Skip      int               `json:"skip,omitempty"`
        SkipDelay int               `json:"skipdelay,omitempty"`
        VideoType string            `json:"videotype,omitempty"`
        RP        rubiconVideoExtRP `json:"rp"`
}

type rubiconVideoExtRP struct {
        SizeID int `json:"size_id,omitempty"`
}

type rubiconDeviceExtRP struct {
        PixelRatio float64 `json:"pixelratio"`
}

type rubiconDeviceExt struct {
        RP rubiconDeviceExtRP `json:"rp"`
}

type rubiconBidResponse struct {
        openrtb2.BidResponse
        SeatBid []rubiconSeatBid `json:"seatbid,omitempty"`
}

type rubiconSeatBid struct {
        openrtb2.SeatBid
        Buyer string       `json:"buyer,omitempty"`
        Bid   []rubiconBid `json:"bid"`
}

type rubiconBid struct {
        openrtb2.Bid
        AdmNative json.RawMessage `json:"adm_native,omitempty"`
}

type extPrebid struct {
        Prebid *openrtb_ext.ExtBidPrebid `json:"prebid,omitempty"`
        Bidder json.RawMessage           `json:"bidder,omitempty"`
}

func appendTrackerToUrl(uri string, tracker string) (res string) <span class="cov8" title="1">{
        // Append integration method. Adapter init happens once
        urlObject, err := url.Parse(uri)
        // No other exception throwing mechanism in this stack, so ignoring parse errors.
        if err == nil </span><span class="cov8" title="1">{
                values := urlObject.Query()
                values.Add("tk_xint", tracker)
                urlObject.RawQuery = values.Encode()
                res = urlObject.String()
        }</span> else<span class="cov0" title="0"> {
                res = uri
        }</span>
        <span class="cov8" title="1">return</span>
}

// Builder builds a new instance of the Rubicon adapter for the given bidder with the given config.
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov8" title="1">{
        uri := appendTrackerToUrl(config.Endpoint, config.XAPI.Tracker)

        bidder := &amp;RubiconAdapter{
                URI:          uri,
                externalURI:  server.ExternalUrl,
                XAPIUsername: config.XAPI.Username,
                XAPIPassword: config.XAPI.Password,
        }
        return bidder, nil
}</span>

func updateRequestTo26(r *openrtb2.BidRequest) error <span class="cov8" title="1">{
        if r.Regs != nil </span><span class="cov8" title="1">{
                regsCopy := *r.Regs
                r.Regs = &amp;regsCopy
        }</span>

        <span class="cov8" title="1">if r.Source != nil </span><span class="cov8" title="1">{
                sourceCopy := *r.Source
                r.Source = &amp;sourceCopy
        }</span>

        <span class="cov8" title="1">if r.User != nil </span><span class="cov8" title="1">{
                userCopy := *r.User
                r.User = &amp;userCopy
        }</span>

        <span class="cov8" title="1">requestWrapper := &amp;openrtb_ext.RequestWrapper{BidRequest: r}

        if err := openrtb_ext.ConvertUpTo26(requestWrapper); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return requestWrapper.RebuildRequest()</span>
}

func (a *RubiconAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) <span class="cov8" title="1">{

        err := updateRequestTo26(request)

        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">numRequests := len(request.Imp)
        requestData := make([]*adapters.RequestData, 0, numRequests)
        headers := http.Header{}
        headers.Add("Content-Type", "application/json;charset=utf-8")
        headers.Add("Accept", "application/json")
        headers.Add("User-Agent", "prebid-server/1.0")

        impsToExtNotGrouped, errs := createImpsToExtMap(request.Imp)
        impsToExtMap := prepareImpsToExtMap(impsToExtNotGrouped)

        rubiconRequest := *request
        for imp, bidderExt := range impsToExtMap </span><span class="cov8" title="1">{
                rubiconExt := bidderExt.Bidder
                target, err := a.updateImpRpTarget(bidderExt, rubiconExt, *imp, request.Site, request.App)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">siteId, err := rubiconExt.SiteId.Int64()
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">zoneId, err := rubiconExt.ZoneId.Int64()
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">impExt := rubiconImpExt{
                        RP: rubiconImpExtRP{
                                ZoneID: int(zoneId),
                                Target: target,
                                Track:  rubiconImpExtRPTrack{Mint: "", MintVersion: ""},
                        },
                        GPID:  bidderExt.Gpid,
                        Skadn: bidderExt.Skadn,
                        Tid:   bidderExt.Tid,
                }

                imp.Ext, err = json.Marshal(&amp;impExt)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">secure := int8(1)
                imp.Secure = &amp;secure

                resolvedBidFloor, err := resolveBidFloor(imp.BidFloor, imp.BidFloorCur, reqInfo)
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, &amp;errortypes.BadInput{
                                Message: fmt.Sprintf("Unable to convert provided bid floor currency from %s to USD",
                                        imp.BidFloorCur),
                        })
                        continue</span>
                }

                <span class="cov8" title="1">if resolvedBidFloor &gt;= 0 </span><span class="cov8" title="1">{
                        imp.BidFloor = resolvedBidFloor
                        if imp.BidFloorCur != "" </span><span class="cov8" title="1">{
                                imp.BidFloorCur = "USD"
                        }</span>
                }

                <span class="cov8" title="1">if request.User != nil </span><span class="cov8" title="1">{
                        userCopy := *request.User
                        target, err := updateUserRpTargetWithFpdAttributes(rubiconExt.Visitor, userCopy)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">userExtRP := rubiconUserExt{RP: rubiconUserExtRP{Target: target}}

                        if len(userCopy.EIDs) &gt; 0 </span><span class="cov8" title="1">{
                                userExtRP.Eids = userCopy.EIDs
                        }</span>

                        <span class="cov8" title="1">if userCopy.Consent != "" </span><span class="cov8" title="1">{
                                userExtRP.Consent = userCopy.Consent
                                userCopy.Consent = ""
                        }</span>

                        <span class="cov8" title="1">userCopy.Ext, err = json.Marshal(&amp;userExtRP)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">userCopy.Geo = nil
                        userCopy.Yob = 0
                        userCopy.Gender = ""
                        userCopy.EIDs = nil

                        rubiconRequest.User = &amp;userCopy</span>
                }

                <span class="cov8" title="1">if request.Device != nil </span><span class="cov8" title="1">{
                        deviceCopy := *request.Device
                        deviceExt := rubiconDeviceExt{RP: rubiconDeviceExtRP{PixelRatio: request.Device.PxRatio}}
                        deviceCopy.Ext, err = json.Marshal(&amp;deviceExt)
                        rubiconRequest.Device = &amp;deviceCopy
                }</span>

                <span class="cov8" title="1">isVideo := isVideo(*imp)
                impType := openrtb_ext.BidTypeVideo
                requestNative := make(map[string]interface{})
                if isVideo </span><span class="cov8" title="1">{
                        videoCopy := *imp.Video

                        // if imp.rwdd = 1, set imp.video.ext.videotype = "rewarded"
                        var videoType = ""
                        if imp.Rwdd == 1 </span><span class="cov8" title="1">{
                                videoType = "rewarded"
                                imp.Rwdd = 0
                        }</span>
                        <span class="cov8" title="1">videoExt := rubiconVideoExt{
                                Skip:      rubiconExt.Video.Skip,
                                SkipDelay: rubiconExt.Video.SkipDelay,
                                VideoType: videoType,
                                RP:        rubiconVideoExtRP{SizeID: rubiconExt.Video.VideoSizeID},
                        }
                        videoCopy.Ext, err = json.Marshal(&amp;videoExt)
                        imp.Video = &amp;videoCopy
                        imp.Banner = nil
                        imp.Native = nil</span>
                } else<span class="cov8" title="1"> if imp.Banner != nil </span><span class="cov8" title="1">{
                        bannerCopy := *imp.Banner
                        if len(bannerCopy.Format) &lt; 1 &amp;&amp; (bannerCopy.W == nil || *bannerCopy.W == 0 &amp;&amp; bannerCopy.H == nil || *bannerCopy.H == 0) </span><span class="cov8" title="1">{
                                errs = append(errs, &amp;errortypes.BadInput{
                                        Message: "rubicon imps must have at least one imp.format element",
                                })
                                continue</span>
                        }
                        <span class="cov8" title="1">bannerCopy.Ext = bannerExtContent
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">imp.Banner = &amp;bannerCopy
                        imp.Video = nil
                        imp.Native = nil
                        impType = openrtb_ext.BidTypeBanner</span>
                } else<span class="cov8" title="1"> {
                        native, err := resolveNativeObject(imp.Native, requestNative)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">imp.Native = native
                        imp.Video = nil
                        impType = openrtb_ext.BidTypeNative</span>
                }

                <span class="cov8" title="1">accountId, err := rubiconExt.AccountId.Int64()
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">pubExt := rubiconPubExt{RP: rubiconPubExtRP{AccountID: int(accountId)}}

                if request.Site != nil </span><span class="cov8" title="1">{
                        siteCopy := *request.Site
                        siteExtRP := rubiconSiteExt{RP: rubiconSiteExtRP{SiteID: int(siteId)}}
                        if siteCopy.Content != nil </span><span class="cov8" title="1">{
                                siteTarget := make(map[string]interface{})
                                updateExtWithIabAttribute(siteTarget, siteCopy.Content.Data, []int{1, 2, 5, 6})
                                if len(siteTarget) &gt; 0 </span><span class="cov8" title="1">{
                                        updatedSiteTarget, err := json.Marshal(siteTarget)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">siteExtRP.RP.Target = updatedSiteTarget</span>
                                }
                        }

                        <span class="cov8" title="1">siteCopy.Ext, err = json.Marshal(&amp;siteExtRP)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">siteCopy.Publisher = &amp;openrtb2.Publisher{}
                        siteCopy.Publisher.Ext, err = json.Marshal(&amp;pubExt)
                        rubiconRequest.Site = &amp;siteCopy</span>
                } else<span class="cov8" title="1"> {
                        appCopy := *request.App
                        appCopy.Ext, err = json.Marshal(rubiconSiteExt{RP: rubiconSiteExtRP{SiteID: int(siteId)}})
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, &amp;errortypes.BadInput{Message: err.Error()})
                        }</span>
                        <span class="cov8" title="1">appCopy.Publisher = &amp;openrtb2.Publisher{}
                        appCopy.Publisher.Ext, err = json.Marshal(&amp;pubExt)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, &amp;errortypes.BadInput{Message: err.Error()})
                        }</span>
                        <span class="cov8" title="1">rubiconRequest.App = &amp;appCopy</span>
                }

                <span class="cov8" title="1">if request.Source != nil &amp;&amp; request.Source.SChain != nil </span><span class="cov8" title="1">{
                        sourceCopy := *request.Source

                        var sourceCopyExt openrtb_ext.ExtSource
                        if sourceCopy.Ext != nil </span><span class="cov0" title="0">{
                                if err = jsonutil.Unmarshal(sourceCopy.Ext, &amp;sourceCopyExt); err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, &amp;errortypes.BadInput{Message: err.Error()})
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                sourceCopyExt = openrtb_ext.ExtSource{}
                        }</span>

                        <span class="cov8" title="1">sourceCopyExt.SChain = sourceCopy.SChain
                        sourceCopy.SChain = nil

                        sourceCopy.Ext, err = json.Marshal(&amp;sourceCopyExt)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">rubiconRequest.Source = &amp;sourceCopy</span>
                }

                <span class="cov8" title="1">if request.Regs != nil &amp;&amp; (request.Regs.GDPR != nil || request.Regs.USPrivacy != "") </span><span class="cov8" title="1">{
                        regsCopy := *request.Regs

                        var regsCopyExt openrtb_ext.ExtRegs
                        if regsCopy.Ext != nil </span><span class="cov0" title="0">{
                                if err = jsonutil.Unmarshal(regsCopy.Ext, &amp;regsCopyExt); err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, &amp;errortypes.BadInput{Message: err.Error()})
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                regsCopyExt = openrtb_ext.ExtRegs{}
                        }</span>

                        <span class="cov8" title="1">if regsCopy.GDPR != nil </span><span class="cov8" title="1">{
                                regsCopyExt.GDPR = regsCopy.GDPR
                        }</span>
                        <span class="cov8" title="1">if regsCopy.USPrivacy != "" </span><span class="cov8" title="1">{
                                regsCopyExt.USPrivacy = regsCopy.USPrivacy
                        }</span>

                        <span class="cov8" title="1">regsCopy.Ext, err = json.Marshal(&amp;regsCopyExt)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">regsCopy.GDPR = nil
                        regsCopy.USPrivacy = ""

                        rubiconRequest.Regs = &amp;regsCopy</span>
                }

                <span class="cov8" title="1">reqBadv := request.BAdv
                if reqBadv != nil </span><span class="cov8" title="1">{
                        if len(reqBadv) &gt; badvLimitSize </span><span class="cov8" title="1">{
                                rubiconRequest.BAdv = reqBadv[:badvLimitSize]
                        }</span>
                }

                <span class="cov8" title="1">rubiconRequest.Imp = []openrtb2.Imp{*imp}
                rubiconRequest.Cur = nil
                rubiconRequest.Ext = nil

                reqJSON, err := json.Marshal(rubiconRequest)
                if impType == openrtb_ext.BidTypeNative &amp;&amp; len(requestNative) &gt; 0 </span><span class="cov8" title="1">{
                        reqJSON, err = setImpNative(reqJSON, requestNative)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">reqData := &amp;adapters.RequestData{
                        Method:  "POST",
                        Uri:     a.URI,
                        Body:    reqJSON,
                        Headers: headers,
                        ImpIDs:  openrtb_ext.GetImpIDs(rubiconRequest.Imp),
                }
                reqData.SetBasicAuth(a.XAPIUsername, a.XAPIPassword)
                requestData = append(requestData, reqData)</span>
        }

        <span class="cov8" title="1">return requestData, errs</span>
}

func createImpsToExtMap(imps []openrtb2.Imp) (map[*openrtb2.Imp]rubiconExtImpBidder, []error) <span class="cov8" title="1">{
        impsToExtMap := make(map[*openrtb2.Imp]rubiconExtImpBidder)
        errs := make([]error, 0)
        var err error
        for _, imp := range imps </span><span class="cov8" title="1">{
                impCopy := imp
                var bidderExt rubiconExtImpBidder
                if err = jsonutil.Unmarshal(imp.Ext, &amp;bidderExt); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, &amp;errortypes.BadInput{
                                Message: err.Error(),
                        })
                        continue</span>
                }
                <span class="cov8" title="1">impsToExtMap[&amp;impCopy] = bidderExt</span>
        }

        <span class="cov8" title="1">return impsToExtMap, errs</span>
}

func prepareImpsToExtMap(impsToExtMap map[*openrtb2.Imp]rubiconExtImpBidder) map[*openrtb2.Imp]rubiconExtImpBidder <span class="cov8" title="1">{
        preparedImpsToExtMap := make(map[*openrtb2.Imp]rubiconExtImpBidder)
        for imp, bidderExt := range impsToExtMap </span><span class="cov8" title="1">{
                if bidderExt.Bidder.BidOnMultiformat == false </span><span class="cov8" title="1">{ //nolint: gosimple,staticcheck
                        impCopy := imp
                        preparedImpsToExtMap[impCopy] = bidderExt
                        continue</span>
                }

                <span class="cov8" title="1">splitImps := splitMultiFormatImp(imp)
                for _, imp := range splitImps </span><span class="cov8" title="1">{
                        impCopy := imp
                        preparedImpsToExtMap[impCopy] = bidderExt
                }</span>
        }

        <span class="cov8" title="1">return preparedImpsToExtMap</span>
}

func splitMultiFormatImp(imp *openrtb2.Imp) []*openrtb2.Imp <span class="cov8" title="1">{
        splitImps := make([]*openrtb2.Imp, 0)
        if imp.Banner != nil </span><span class="cov8" title="1">{
                impCopy := *imp
                impCopy.Video = nil
                impCopy.Native = nil
                impCopy.Audio = nil
                splitImps = append(splitImps, &amp;impCopy)
        }</span>

        <span class="cov8" title="1">if imp.Video != nil </span><span class="cov8" title="1">{
                impCopy := *imp
                impCopy.Banner = nil
                impCopy.Native = nil
                impCopy.Audio = nil
                splitImps = append(splitImps, &amp;impCopy)
        }</span>

        <span class="cov8" title="1">if imp.Native != nil </span><span class="cov0" title="0">{
                impCopy := *imp
                impCopy.Banner = nil
                impCopy.Video = nil
                impCopy.Audio = nil
                splitImps = append(splitImps, &amp;impCopy)
        }</span>

        <span class="cov8" title="1">if imp.Audio != nil </span><span class="cov0" title="0">{
                impCopy := *imp
                impCopy.Banner = nil
                impCopy.Video = nil
                impCopy.Native = nil
                splitImps = append(splitImps, &amp;impCopy)
        }</span>

        <span class="cov8" title="1">return splitImps</span>
}

func resolveBidFloor(bidFloor float64, bidFloorCur string, reqInfo *adapters.ExtraRequestInfo) (float64, error) <span class="cov8" title="1">{
        if bidFloor &gt; 0 &amp;&amp; bidFloorCur != "" &amp;&amp; strings.ToUpper(bidFloorCur) != "USD" </span><span class="cov8" title="1">{
                return reqInfo.ConvertCurrency(bidFloor, bidFloorCur, "USD")
        }</span>

        <span class="cov8" title="1">return bidFloor, nil</span>
}

func (a *RubiconAdapter) updateImpRpTarget(extImp rubiconExtImpBidder, extImpRubicon openrtb_ext.ExtImpRubicon,
        imp openrtb2.Imp, site *openrtb2.Site, app *openrtb2.App) (json.RawMessage, error) <span class="cov8" title="1">{

        existingTarget, _, _, err := jsonparser.Get(imp.Ext, "rp", "target")
        if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">target, err := rawJSONToMap(existingTarget)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = populateFirstPartyDataAttributes(extImpRubicon.Inventory, target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if site != nil </span><span class="cov8" title="1">{
                siteExtData, _, _, err := jsonparser.Get(site.Ext, "data")
                if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = populateFirstPartyDataAttributes(siteExtData, target)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if site.Page != "" </span><span class="cov8" title="1">{
                        addStringAttribute(site.Page, target, "page")
                }</span>
        } else<span class="cov8" title="1"> {
                appExtData, _, _, err := jsonparser.Get(app.Ext, "data")
                if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = populateFirstPartyDataAttributes(appExtData, target)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if len(extImp.Data) &gt; 0 </span><span class="cov8" title="1">{
                err = populateFirstPartyDataAttributes(extImp.Data, target)
        }</span>
        <span class="cov8" title="1">if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var data rubiconData
        if len(extImp.Data) &gt; 0 </span><span class="cov8" title="1">{
                err := jsonutil.Unmarshal(extImp.Data, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if data.PbAdSlot != "" </span><span class="cov8" title="1">{
                target["pbadslot"] = data.PbAdSlot
        }</span> else<span class="cov8" title="1"> {
                dfpAdUnitCode := extractDfpAdUnitCode(data)
                if dfpAdUnitCode != "" </span><span class="cov8" title="1">{
                        target["dfp_ad_unit_code"] = dfpAdUnitCode
                }</span>
        }

        <span class="cov8" title="1">if len(extImpRubicon.Keywords) &gt; 0 </span><span class="cov0" title="0">{
                addStringArrayAttribute(extImpRubicon.Keywords, target, "keywords")
        }</span>

        <span class="cov8" title="1">target["pbs_login"] = a.XAPIUsername
        target["pbs_version"] = version.Ver
        target["pbs_url"] = a.externalURI

        updatedTarget, err := json.Marshal(target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return updatedTarget, nil</span>
}

func extractDfpAdUnitCode(data rubiconData) string <span class="cov8" title="1">{
        if data.AdServer.Name == "gam" &amp;&amp; len(data.AdServer.AdSlot) != 0 </span><span class="cov8" title="1">{
                return data.AdServer.AdSlot
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func isNotKeyPathError(err error) bool <span class="cov8" title="1">{
        return err != nil &amp;&amp; err != jsonparser.KeyPathNotFoundError
}</span>

func addStringAttribute(attribute string, target map[string]interface{}, attributeName string) <span class="cov8" title="1">{
        target[attributeName] = [1]string{attribute}
}</span>

func addStringArrayAttribute(attribute []string, target map[string]interface{}, attributeName string) <span class="cov0" title="0">{
        target[attributeName] = attribute
}</span>

func updateUserRpTargetWithFpdAttributes(visitor json.RawMessage, user openrtb2.User) (json.RawMessage, error) <span class="cov8" title="1">{
        existingTarget, _, _, err := jsonparser.Get(user.Ext, "rp", "target")
        if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">target, err := rawJSONToMap(existingTarget)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = populateFirstPartyDataAttributes(visitor, target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">userExtData, _, _, err := jsonparser.Get(user.Ext, "data")
        if isNotKeyPathError(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = populateFirstPartyDataAttributes(userExtData, target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">updateExtWithIabAttribute(target, user.Data, []int{4})

        updatedTarget, err := json.Marshal(target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return updatedTarget, nil</span>
}

func updateExtWithIabAttribute(target map[string]interface{}, data []openrtb2.Data, segTaxes []int) <span class="cov8" title="1">{
        var segmentIdsToCopy = getSegmentIdsToCopy(data, segTaxes)
        if len(segmentIdsToCopy) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">target["iab"] = segmentIdsToCopy</span>
}

func populateFirstPartyDataAttributes(source json.RawMessage, target map[string]interface{}) error <span class="cov8" title="1">{
        sourceAsMap, err := rawJSONToMap(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for key, val := range sourceAsMap </span><span class="cov8" title="1">{
                switch typedValue := val.(type) </span>{
                case string:<span class="cov8" title="1">
                        target[key] = [1]string{typedValue}</span>
                case float64:<span class="cov8" title="1">
                        if typedValue == float64(int(typedValue)) </span><span class="cov8" title="1">{
                                target[key] = [1]string{strconv.Itoa(int(typedValue))}
                        }</span>
                case bool:<span class="cov8" title="1">
                        target[key] = [1]string{strconv.FormatBool(typedValue)}</span>
                case []interface{}:<span class="cov8" title="1">
                        if isStringArray(typedValue) </span><span class="cov8" title="1">{
                                target[key] = typedValue
                        }</span>
                        <span class="cov8" title="1">if isBoolArray(typedValue) </span><span class="cov8" title="1">{
                                target[key] = convertToStringArray(typedValue)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func isStringArray(array []interface{}) bool <span class="cov8" title="1">{
        for _, val := range array </span><span class="cov8" title="1">{
                if _, ok := val.(string); !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func isBoolArray(array []interface{}) bool <span class="cov8" title="1">{
        for _, val := range array </span><span class="cov8" title="1">{
                if _, ok := val.(bool); !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func convertToStringArray(arr []interface{}) []string <span class="cov8" title="1">{
        var stringArray []string
        for _, val := range arr </span><span class="cov8" title="1">{
                if boolVal, ok := val.(bool); ok </span><span class="cov8" title="1">{
                        stringArray = append(stringArray, strconv.FormatBool(boolVal))
                }</span>
        }

        <span class="cov8" title="1">return stringArray</span>
}

func rawJSONToMap(message json.RawMessage) (map[string]interface{}, error) <span class="cov8" title="1">{
        if message == nil </span><span class="cov8" title="1">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov8" title="1">return mapFromRawJSON(message)</span>
}

func mapFromRawJSON(message json.RawMessage) (map[string]interface{}, error) <span class="cov8" title="1">{
        targetAsMap := make(map[string]interface{})
        err := jsonutil.Unmarshal(message, &amp;targetAsMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return targetAsMap, nil</span>
}

func getSegmentIdsToCopy(data []openrtb2.Data, segTaxValues []int) []string <span class="cov8" title="1">{
        var segmentIdsToCopy = make([]string, 0, len(data))

        for _, dataRecord := range data </span><span class="cov8" title="1">{
                if dataRecord.Ext != nil </span><span class="cov8" title="1">{
                        var dataExtObject rubiconDataExt
                        err := jsonutil.Unmarshal(dataRecord.Ext, &amp;dataExtObject)
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if contains(segTaxValues, dataExtObject.SegTax) </span><span class="cov8" title="1">{
                                for _, segment := range dataRecord.Segment </span><span class="cov8" title="1">{
                                        segmentIdsToCopy = append(segmentIdsToCopy, segment.ID)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return segmentIdsToCopy</span>
}

func contains(s []int, e int) bool <span class="cov8" title="1">{
        for _, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isVideo(imp openrtb2.Imp) bool <span class="cov8" title="1">{
        video := imp.Video
        if video != nil </span><span class="cov8" title="1">{
                // Do any other media types exist? Or check required video fields.
                return imp.Banner == nil || isFullyPopulatedVideo(video)
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isFullyPopulatedVideo(video *openrtb2.Video) bool <span class="cov8" title="1">{
        // These are just recommended video fields for XAPI
        return video.MIMEs != nil &amp;&amp; video.Protocols != nil &amp;&amp; video.MaxDuration != 0 &amp;&amp; video.Linearity != 0
}</span>

func resolveNativeObject(native *openrtb2.Native, target map[string]interface{}) (*openrtb2.Native, error) <span class="cov8" title="1">{
        if native == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Native object is not present for request")
        }</span>
        <span class="cov8" title="1">ver := native.Ver
        if ver == "1.0" || ver == "1.1" </span><span class="cov8" title="1">{
                return native, nil
        }</span>

        <span class="cov8" title="1">err := jsonutil.Unmarshal([]byte(native.Request), &amp;target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if _, ok := target["eventtrackers"].([]interface{}); !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Eventtrackers are not present or not of array type")
        }</span>

        <span class="cov8" title="1">context := target["context"]
        if context != nil </span><span class="cov8" title="1">{
                if _, ok := context.(float64); !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Context is not of int type")
                }</span>
        }

        <span class="cov8" title="1">if _, ok := target["plcmttype"].(float64); !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Plcmttype is not present or not of int type")
        }</span>

        <span class="cov8" title="1">return native, nil</span>
}

func setImpNative(jsonData []byte, requestNative map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        var jsonMap map[string]interface{}
        if err := jsonutil.Unmarshal(jsonData, &amp;jsonMap); err != nil </span><span class="cov0" title="0">{
                return jsonData, err
        }</span>

        <span class="cov8" title="1">var impMap map[string]interface{}
        if impSlice, ok := maputil.ReadEmbeddedSlice(jsonMap, "imp"); !ok </span><span class="cov8" title="1">{
                return jsonData, fmt.Errorf("unable to find imp in json data")
        }</span> else<span class="cov8" title="1"> if len(impSlice) == 0 </span><span class="cov8" title="1">{
                return jsonData, fmt.Errorf("unable to find imp[0] in json data")
        }</span> else<span class="cov8" title="1"> if impMap, ok = impSlice[0].(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                return jsonData, fmt.Errorf("unexpected type for imp[0] found in json data")
        }</span>

        <span class="cov8" title="1">nativeMap, ok := maputil.ReadEmbeddedMap(impMap, "native")
        if !ok </span><span class="cov8" title="1">{
                return jsonData, fmt.Errorf("unable to find imp[0].native in json data")
        }</span>

        <span class="cov8" title="1">nativeMap["request_native"] = requestNative

        if jsonReEncoded, err := json.Marshal(jsonMap); err == nil </span><span class="cov8" title="1">{
                return jsonReEncoded, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unable to encode json data (%v)", err)
        }</span>
}

func (a *RubiconAdapter) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) <span class="cov8" title="1">{
        if response.StatusCode == http.StatusNoContent </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if response.StatusCode == http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, []error{&amp;errortypes.BadInput{
                        Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
                }}
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
                }}
        }</span>

        <span class="cov8" title="1">var bidResp rubiconBidResponse
        if err := jsonutil.Unmarshal(response.Body, &amp;bidResp); err != nil </span><span class="cov0" title="0">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: err.Error(),
                }}
        }</span>

        <span class="cov8" title="1">var bidReq openrtb2.BidRequest
        if err := jsonutil.Unmarshal(externalRequest.Body, &amp;bidReq); err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">bidResponse := adapters.NewBidderResponseWithBidsCapacity(5)

        bidType := openrtb_ext.BidTypeNative

        isVideo := isVideo(bidReq.Imp[0])
        if isVideo </span><span class="cov8" title="1">{
                bidType = openrtb_ext.BidTypeVideo
        }</span> else<span class="cov8" title="1"> if bidReq.Imp[0].Banner != nil </span><span class="cov8" title="1">{
                bidType = openrtb_ext.BidTypeBanner
        }</span>

        <span class="cov8" title="1">impToCpmOverride := mapImpIdToCpmOverride(internalRequest.Imp)
        cmpOverride := cmpOverrideFromBidRequest(internalRequest)

        for _, sb := range bidResp.SeatBid </span><span class="cov8" title="1">{
                buyer, err := strconv.Atoi(sb.Buyer)
                if err != nil </span><span class="cov8" title="1">{
                        buyer = 0
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; len(sb.Bid); i++ </span><span class="cov8" title="1">{
                        bid := sb.Bid[i]

                        updatedBidExt := updateBidExtWithMeta(bid, buyer, sb.Seat)
                        if updatedBidExt != nil </span><span class="cov8" title="1">{
                                bid.Ext = updatedBidExt
                        }</span>
                        <span class="cov8" title="1">bidCmpOverride, ok := impToCpmOverride[bid.ImpID]
                        if !ok || bidCmpOverride == 0 </span><span class="cov8" title="1">{
                                bidCmpOverride = cmpOverride
                        }</span>

                        <span class="cov8" title="1">if bidCmpOverride &gt; 0 </span><span class="cov8" title="1">{
                                bid.Price = bidCmpOverride
                        }</span>

                        <span class="cov8" title="1">if bid.Price != 0 </span><span class="cov8" title="1">{
                                // Since Rubicon XAPI returns only one bid per response
                                // copy response.bidid to openrtb_response.seatbid.bid.bidid
                                if bid.ID == "0" </span><span class="cov8" title="1">{
                                        bid.ID = bidResp.BidID
                                }</span>

                                <span class="cov8" title="1">resolvedAdm := resolveAdm(bid)
                                if len(resolvedAdm) &gt; 0 </span><span class="cov8" title="1">{
                                        bid.AdM = resolvedAdm
                                }</span>

                                <span class="cov8" title="1">var ortbBid openrtb2.Bid // `targetStruct` can be anything of your choice

                                rubiconBidAsBytes, _ := json.Marshal(bid)
                                if len(rubiconBidAsBytes) &gt; 0 </span><span class="cov8" title="1">{
                                        err = jsonutil.Unmarshal(rubiconBidAsBytes, &amp;ortbBid)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, []error{err}
                                        }</span>
                                }

                                <span class="cov8" title="1">bidResponse.Bids = append(bidResponse.Bids, &amp;adapters.TypedBid{
                                        Bid:     &amp;ortbBid,
                                        BidType: bidType,
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">if bidResp.Cur != "" </span><span class="cov8" title="1">{
                bidResponse.Currency = bidResp.Cur
        }</span>

        <span class="cov8" title="1">return bidResponse, nil</span>
}

func mapImpIdToCpmOverride(imps []openrtb2.Imp) map[string]float64 <span class="cov8" title="1">{
        impIdToCmpOverride := make(map[string]float64)
        for _, imp := range imps </span><span class="cov8" title="1">{
                var bidderExt adapters.ExtImpBidder
                if err := jsonutil.Unmarshal(imp.Ext, &amp;bidderExt); err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var rubiconExt openrtb_ext.ExtImpRubicon
                if err := jsonutil.Unmarshal(bidderExt.Bidder, &amp;rubiconExt); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">impIdToCmpOverride[imp.ID] = rubiconExt.Debug.CpmOverride</span>
        }
        <span class="cov8" title="1">return impIdToCmpOverride</span>
}

func resolveAdm(bid rubiconBid) string <span class="cov8" title="1">{
        var bidAdm = bid.AdM
        if len(bidAdm) &gt; 0 </span><span class="cov8" title="1">{
                return bidAdm
        }</span>

        <span class="cov8" title="1">admObject := bid.AdmNative
        admObjectAsBytes, err := json.Marshal(&amp;admObject)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return string(admObjectAsBytes)</span>
}

func cmpOverrideFromBidRequest(bidRequest *openrtb2.BidRequest) float64 <span class="cov8" title="1">{
        var bidRequestExt bidRequestExt
        if err := jsonutil.Unmarshal(bidRequest.Ext, &amp;bidRequestExt); err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return bidRequestExt.Prebid.Bidders.Rubicon.Debug.CpmOverride</span>
}

func updateBidExtWithMeta(bid rubiconBid, buyer int, seat string) json.RawMessage <span class="cov8" title="1">{
        if buyer &lt;= 0 &amp;&amp; seat == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var bidExt *extPrebid
        if bid.Ext != nil </span><span class="cov8" title="1">{
                if err := jsonutil.Unmarshal(bid.Ext, &amp;bidExt); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if bidExt != nil </span><span class="cov8" title="1">{
                if bidExt.Prebid != nil </span><span class="cov8" title="1">{
                        if bidExt.Prebid.Meta != nil </span><span class="cov8" title="1">{
                                bidExt.Prebid.Meta.NetworkID = buyer
                                bidExt.Prebid.Meta.Seat = seat
                        }</span> else<span class="cov8" title="1"> {
                                bidExt.Prebid.Meta = &amp;openrtb_ext.ExtBidPrebidMeta{NetworkID: buyer, Seat: seat}
                        }</span>
                } else<span class="cov0" title="0"> {
                        bidExt.Prebid = &amp;openrtb_ext.ExtBidPrebid{Meta: &amp;openrtb_ext.ExtBidPrebidMeta{NetworkID: buyer, Seat: seat}}
                }</span>
        } else<span class="cov8" title="1"> {
                bidExt = &amp;extPrebid{Prebid: &amp;openrtb_ext.ExtBidPrebid{Meta: &amp;openrtb_ext.ExtBidPrebidMeta{NetworkID: buyer, Seat: seat}}}
        }</span>

        <span class="cov8" title="1">marshalledExt, err := json.Marshal(&amp;bidExt)
        if err == nil </span><span class="cov8" title="1">{
                return marshalledExt
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
